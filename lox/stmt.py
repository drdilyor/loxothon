"""AUTOGENERATED! DO NOT EDIT! Make changes to tool/generate_ast.py instead"""
from abc import ABC, abstractmethod
from typing import Any, Generic, List, Optional, TypeVar
from collections import namedtuple
from lox.token import Token
from lox.expr import Expr

T = TypeVar('T')

class Stmt:
    def accept(self, visitor: 'Visitor[T]') -> T: ...
    def __hash__(self): return id(self)

class Block(Stmt, namedtuple('Block', 'statements')):
    statements: List[Stmt]

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_block_stmt(self)

class Break(Stmt, namedtuple('Break', 'keyword')):
    keyword: Token

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_break_stmt(self)

class Class(Stmt, namedtuple('Class', 'name methods setters class_methods class_setters')):
    name: Token
    methods: List['Function']
    setters: List['Function']
    class_methods: List['Function']
    class_setters: List['Function']

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_class_stmt(self)

class Expression(Stmt, namedtuple('Expression', 'expression')):
    expression: Expr

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_expression_stmt(self)

class Function(Stmt, namedtuple('Function', 'name params body is_getter is_setter')):
    name: Token
    params: List[Token]
    body: List[Stmt]
    is_getter: bool
    is_setter: bool

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_function_stmt(self)

class If(Stmt, namedtuple('If', 'condition then_branch else_branch')):
    condition: Expr
    then_branch: Stmt
    else_branch: Stmt

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_if_stmt(self)

class Print(Stmt, namedtuple('Print', 'expression')):
    expression: Expr

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_print_stmt(self)

class Return(Stmt, namedtuple('Return', 'keyword value')):
    keyword: Token
    value: Expr

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_return_stmt(self)

class Var(Stmt, namedtuple('Var', 'name initializer')):
    name: Token
    initializer: Optional[Expr]

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_var_stmt(self)

class While(Stmt, namedtuple('While', 'condition body')):
    condition: Expr
    body: Stmt

    def accept(self, visitor: 'Visitor[T]') -> T:
        return visitor.visit_while_stmt(self)

R = TypeVar('R')

class Visitor(Generic[R], ABC):
    @abstractmethod
    def visit_block_stmt(self, s: Block) -> R: ...
    @abstractmethod
    def visit_break_stmt(self, s: Break) -> R: ...
    @abstractmethod
    def visit_class_stmt(self, s: Class) -> R: ...
    @abstractmethod
    def visit_expression_stmt(self, s: Expression) -> R: ...
    @abstractmethod
    def visit_function_stmt(self, s: Function) -> R: ...
    @abstractmethod
    def visit_if_stmt(self, s: If) -> R: ...
    @abstractmethod
    def visit_print_stmt(self, s: Print) -> R: ...
    @abstractmethod
    def visit_return_stmt(self, s: Return) -> R: ...
    @abstractmethod
    def visit_var_stmt(self, s: Var) -> R: ...
    @abstractmethod
    def visit_while_stmt(self, s: While) -> R: ...
